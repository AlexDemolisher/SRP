--'------------------------------------------------------
--' Enemy functions
--'------------------------------------------------------

function is_enemy_actor(enemy, object)
	return enemy:id() == db.actor:id()
end

function fighting_dist_ge(enemy, npc, p)				-- if p[1] == nil, crashes the game
	local d = p[1]
	return enemy:position():distance_to_sqr(npc:position()) >= d * d
end

function fighting_dist_le(enemy, npc, p)				-- if p[1] == nil, crashes the game
	local d = p[1]
	return enemy:position():distance_to_sqr(npc:position()) <= d * d
end

function enemy_in_zone(enemy, npc, p)					-- if p[1] == nil, crash the game
	local zone = db.zone_by_name[p[1]]
	if zone == nil then
		abort("[xr_conditions.enemy_in_zone]: No zone corresponds to parameter %s for NPC %s.", tostring(p[1]), npc:name())
	end
	return utils.npc_in_zone(enemy, zone)
end

--'------------------------------------------------------
--' Miscellaneous
--'------------------------------------------------------

function black_screen(actor, npc)
	return device().precache_frame > 1
end

function check_npc_name(actor, npc, p)					-- if p[1] == nil, crashes the game

	local npc_name = npc:name()

--	if npc_name == nil then
--		return false
--	end

--	for k, v in pairs (p) do
--		if string.find(npc_name, v) ~= nil then
--			return true
--		end
--	end

--	return false

	return npc_name ~= nil and string.find(npc_name, p[1]) ~= nil
end

function is_playing_sound(actor, npc)
	return xr_sound.sound_table[npc:id()] ~= nil
end

--[[

function check_enemy_name(actor, npc, p)

	local enemy_id = db.storage[npc:id()].enemy_id
	local enemy = db.storage[enemy_id] and db.storage[enemy_id].object

--	if not enemy or not enemy:alive() then
--		return false
--	end

--	local name = enemy:name()
--	for i, v in pairs (p) do
--		if string.find(name, v) ~= nil then
--			return true
--		end
--	end

--	return false

	return enemy ~= nil and enemy:alive() and string.find(name, p[1]) ~= nil
end

function is_actor_sleeping(actor, npc)
	local act = db.actor
--	return db.actor:is_actor_sleeping()
	return act and act:is_actor_sleeping()
end

function actor_alive(actor, npc)
	local act = db.actor
	return act and act:alive()
end

function actor_dead(actor, npc)
	local act = db.actor
	return act and not act:alive()
end

]]

--'------------------------------------------------------
--' Visibility functions
--'------------------------------------------------------

function actor_see_npc(actor, npc)
	return db.actor:see(npc)
end

function see_actor(actor, npc)
	return npc:alive() and npc:see(actor)
end

--[[

function see_npc(actor, npc, p)
	local npc1 = level_object_by_sid(p[1])
	return npc and npc1 and npc:see(npc1)
end

function npc_in_actor_frustum(actor, npc)
	return npc_in_actor_frustrum(npc)
end

]]

--'------------------------------------------------------
--' Miscellaneous
--'------------------------------------------------------

function dist_to_actor_le(actor, npc, p)				-- if p[1] == nil, now crashes the game instead of returning false
	local d = p[1]
--	return d and npc:position():distance_to_sqr(actor:position()) <= d * d
	return npc:position():distance_to_sqr(actor:position()) <= d * d
end

function dist_to_actor_ge(actor, npc, p)				-- if p[1] == nil, now crashes the game instead of returning false
	local d = p[1]
--	return d and npc:position():distance_to_sqr(actor:position()) >= d * d
	return npc:position():distance_to_sqr(actor:position()) >= d * d
end

function is_obj_on_job(actor, npc, p)					-- if p[1] == nil, returns false

	local smart = xr_gulag.get_npc_smart(npc)
	if smart == nil then
		return false
	end

	local job_sect = p[1]
	for k, v in pairs (smart.npc_info) do
		if smart.job_data[v.job_id].section == job_sect then
			return true
		end
	end

	return false
end

function distance_to_obj_on_job_le(actor, npc, p)			-- if p[1] == nil, returns false; if p[2] == nil, crashes the game

	local smart = xr_gulag.get_npc_smart(npc)
	if smart == nil then						-- +
		return false						-- +
	end								-- +

	local p2 = p[2]
	local max_dist = p2 * p2
	local job_sect = p[1]

	for k, v in pairs (smart.npc_info) do
		if smart.job_data[v.job_id].section == job_sect then
			return npc:position():distance_to_sqr(v.se_obj.position) <= max_dist
		end
	end

	return false
end

function actor_in_zone(actor, npc, p)					-- if p[1] == nil and/or db.zone_by_name[p[1]] == nil, returns false
	local zone = db.zone_by_name[p[1]]
	return utils.npc_in_zone(db.actor, zone)
end

function in_zone(actor, npc, p)						-- if p[1] == nil and/or db.zone_by_name[p[1]] == nil, returns false
	local zone = db.zone_by_name[p[1]]
	return utils.npc_in_zone(npc, zone)
end

function in_zone_by_model_center(actor, npc, p)				-- if p[1] == nil and/or db.zone_by_name[p[1]] == nil, crashes the game
	local zone = db.zone_by_name[p[1]]
	return zone:inside(npc:center())
end

function npc_in_zone(actor, npc, p)					-- if p[1] == nil and/or db.zone_by_name[p[1]] == nil, returns false
	local zone = db.zone_by_name[p[1]]
	return utils.npc_in_zone(npc, zone)
end

function actor_out_zone(actor, npc, p)					-- if p[1] == nil and/or db.zone_by_name[p[1]] == nil, returns false
	local zone = db.zone_by_name[p[1]]
	return zone ~= nil and not utils.npc_in_zone(db.actor, zone)
end

function health_le(actor, npc, p)					-- if p[1] == nil, now crashes the game instead of returning false
--	return p[1] and npc.health < p[1]
	return npc.health < p[1]
end

function heli_health_le(actor, obj, p)					-- if p[1] == nil, now crashes the game instead of returning false
--	return p[1] and obj:get_helicopter():GetfHealth() < p[1]
	return obj:get_helicopter():GetfHealth() < p[1]
end

function npc_community(actor, npc, p)					-- if p[1] == nil, crash the game

	local faction_name = p[1]
	if faction_name == nil then
		abort("[xr_conditions.npc_community]: Parameter missing.")
	end

	local npc_obj
	if npc.id ~= nil then
		npc_obj = db.storage[npc.id] and db.storage[npc.id].object
		if npc_obj == nil then
			return npc:community() == faction_name
		end
	else
		npc_obj = npc
	end

	return npc_obj:character_community() == faction_name
end

function best_pistol(actor, npc)
	return npc:item_in_slot(1) ~= nil
end

function is_alive(actor, npc, p)					-- if p[1] == nil and/or alife():story_object(p[1]) == nil, returns false
--	local npc1 = level_object_by_sid(p[1])				-- don't use this, else when NPC goes offline, this evalutes to nil and func. returns false even though NPC is still alive
	local npc1 = alife():story_object(p[1])
	return npc1 and npc1:alive()
end

function is_dead_all(actor, npc, p)					-- if p[1] == nil and/or alife():story_object(p[1]) == nil, returns true
	local sim, npc1 = alife()
	for i, v in pairs (p) do
--		npc1 = level_object_by_sid(v)
		npc1 = sim:story_object(v)
		if npc1 then
			if npc1:alive() then
				return false
			end
		end
	end
	return true
end

function check_fighting(actor, npc, p)					-- if p[1] == nil, returns false

	local enemy_id = db.storage[npc:id()].enemy_id
	local enemy = db.storage[enemy_id] and db.storage[enemy_id].object
	if not enemy or not enemy:alive() then
		return false
	end

	local enemy_sid = enemy:story_id()
	for i, v in pairs (p) do
		if type(v) == "number" then
			if enemy_sid == v then
				return true
			end
		end
	end

	return false
end

function actor_has_item(actor, npc, p)					-- if p[1] == nil, now crashes the game instead of returning false
--	return p[1] ~= nil and actor:object(p[1]) ~= nil
	return actor:object(p[1]) ~= nil
end

--[[

function is_wounded(actor, npc)
	return xr_wounded.is_wounded(npc)
end

-- duplicate:

function distance_to_obj_ge(actor, npc, p)
	local npc1, dist = level_object_by_sid(p[1]), p[2]
	return npc1 and npc:position():distance_to_sqr(npc1:position()) >= dist * dist
end

function obj_in_zone(actor, zone, p)
	local sim, npc1 = alife()
	for i, v in pairs (p) do
--		npc1 = level_object_by_sid(v)
		npc1 = sim:story_object(v)
		if npc1 then
--			if zone:inside(npc1:position()) then
			if zone:inside(npc1.position) then
				return true
			end
		end
	end
	return false
end

function one_obj_in_zone(actor, zone, p)
--	local obj1 = level_object_by_sid(p[1])
	local obj1 = alife():story_object(p[1])
	if not obj1 then
		return p[2] ~= "false"
	end
--	return zone:inside(obj1:position())
	return zone:inside(obj1.position)
end

function actor_health_le(actor, npc, p)
--	return p[1] and actor.health < p[1]
	return actor.health < p[1]
end

function heli_see_npc(actor, obj, p)
	local heli = level_object_by_sid(p[1])
	return heli ~= nil and obj:get_helicopter():isVisible(heli)
end

-- duplicate:

function heli_see_actor(actor, obj)
	return actor ~= nil and obj:get_helicopter():isVisible(actor)
end

function enemy_group(actor, npc, p)
	local enemy_id = db.storage[npc:id()].enemy_id
	local enemy = db.storage[enemy_id] and db.storage[enemy_id].object
	local g = enemy:group()
	for i, v in pairs (p) do
		if v == g then
			return true
		end
	end
	return false
end

function enemy_gulag(actor, npc, p)

	local enemy_id = db.storage[npc:id()].enemy_id
	local enemy = db.storage[enemy_id] and db.storage[enemy_id].object
	if enemy == nil or not enemy:alive() or enemy:id() == actor:id() then
		return false
	end

	local g = xr_gulag.get_npc_smart(enemy)
	if g == nil then
		return false
	end

	local n = g.name
	for i, v in pairs (p) do
		if n == v then
			return true
		end
	end

	return false
end

function gulag_state(actor, npc, p)
	return xr_gulag.getGulagState(p[1]) == p[2]
end

function npc_rank(actor, npc, p)
	local rank = p[1]
	if rank == nil then
		abort("[xr_conditions.npc_rank]: Parameter missing.")
	end
	return ranks.get_obj_rank_name(npc) == rank
end

function npc_profile(actor, npc, p)
	local profile = p[1]
	if profile == nil then
		abort("[xr_conditions.npc_profile]: Parameter missing.")
	end
	return npc:profile_name() == profile
end

function hitted_by(actor, npc, p)

	local t = db.storage[npc:id()].hit
	if not t then
		return false
	end

	local sim, npc1 = alife()
	for i, v in pairs (p) do
--		npc1 = level_object_by_sid(v)
		npc1 = sim:story_object(v)
		if npc1 then
--			if t.who == npc1:id() then
			if t.who == npc1.id then
				return true
			end
		end
	end

	return false
end

function killed_by(actor, npc, p)

	local t = db.storage[npc:id()].death
	if not t then
		return false
	end

	local sim, npc1 = alife()
	for i, v in pairs (p) do
--		npc1 = level_object_by_sid(v)
		npc1 = sim:story_object(v)
		if npc1 then
--			if t.killer == npc1:id() then
			if t.killer == npc1.id then
				return true
			end
		end
	end

	return false
end

function is_alive_all(actor, npc, p)
	local sim, npc1 = alife()
	for i, v in pairs (p) do
--		npc1 = level_object_by_sid(v)
		npc1 = sim:story_object(v)
		if npc1 then
			if not npc1:alive() then
				return false
			end
		end
	end
	return true
end

function is_alive_one(actor, npc, p)
	local sim, npc1 = alife()
	for i, v in pairs (p) do
		npc1 = sim:story_object(v)
		if npc1 then
			if IsStalker(npc1) then
				if npc1:alive() then
					return true
				end
			end
		end
	end
	return false
end

function is_dead_one(actor, npc, p)
	local sim, npc1 = alife()
	for i, v in pairs (p) do
--		npc1 = level_object_by_sid(v)
		npc1 = sim:story_object(v)
		if not npc1 or not npc1:alive() then
			return true
		end
	end
	return false
end

function is_dead(actor, npc, p)
--	local npc1 = level_object_by_sid(p[1])
	local npc1 = alife():story_object(p[1])
	return not npc1 or not npc1:alive()
end

function gulag_empty(actor, npc, p)
	local gulag = p[1]
	return not gulag or xr_gulag.getGulagPopulationComed(gulag) == 0
end

function gulag_population_le(actor, npc, p)
	local gulag, pop = p[1], p[2]
	return not gulag or not pop or xr_gulag.getGulagPopulation(gulag) <= pop
end

function gulag_population_ge(actor, npc, p)
	local gulag, pop = p[1], p[2]
	return not gulag or not pop or xr_gulag.getGulagPopulation(gulag) >= pop
end

function gulag_population_comed_le(actor, npc, p)
	local gulag, pop = p[1], p[2]
	return not gulag or not pop or xr_gulag.getGulagPopulationComed(gulag) <= pop
end

function gulag_population_comed_ge(actor, npc, p)
	local gulag, pop = p[1], p[2]
	return not gulag or not pop or xr_gulag.getGulagPopulationComed(gulag) >= pop
end

function gulag_population_active(actor, npc, p)

	local gulag = xr_gulag.get_gulag_by_name(p[1])
	if gulag == nil then
		return 0
	end

	local val = 0
	for k, v in pairs (gulag.Object) do
		if v == true or (v:alive() and not (xr_wounded.is_heavy_wounded_by_id(k) or xr_wounded.is_psy_wounded_by_id(k))) then
			if gulag.Object_begin_job[k] == true then
				val = val + 1
			end
		end
	end

	return val
end

function gulag_inactive(actor, npc, p)

	local gulag = xr_gulag.get_gulag_by_name(p[1])
	if gulag == nil then
		return false
	end

	local val = 0
	for k, v in pairs (gulag.Object) do
		if v == true or (v:alive() and not (xr_wounded.is_heavy_wounded_by_id(k) or xr_wounded.is_psy_wounded_by_id(k))) then
			if gulag.Object_begin_job[k] == true then
				val = val + 1
			end
		end
	end

	return val == 0
end

function gulag_population_active_le(actor, npc, p)

	local gulag = xr_gulag.get_gulag_by_name(p[1])
	if gulag == nil then
		return false
	end

	local val = 0
	for k, v in pairs (gulag.Object) do
		if v == true or (v:alive() and not (xr_wounded.is_heavy_wounded_by_id(k) or xr_wounded.is_psy_wounded_by_id(k))) then
			if gulag.Object_begin_job[k] == true then
				val = val + 1
			end
		end
	end

	return val <= p[2]
end

function gulag_casualities_ge(actor, npc, p)
	local casualties, number = p[1], p[2]
	return casualties ~= nil and number ~= nil and xr_gulag.getCasualities(casualties) >= number
end

function signal(actor, npc, p)
	local sig, st = p[1], db.storage[npc:id()]
	local sigs = st[st.active_scheme].signals
	return sig ~= nil and sigs ~= nil and sigs[sig] == true
end

function odd_time_interval(actor, npc, p)
	return odd(game.time() / p[1])
end

]]

--'------------------------------------------------------
--' Counter
--'------------------------------------------------------

function counter_greater(actor, npc, p)					-- if p[1]/p[2] == nil, returns false; if counter doesn't exist, compares against 0
	local counter_name, num = p[1], p[2]
--	local c = xr_logic.pstor_retrieve(actor, counter_name, 0)
--	return counter_name and num and c > num
	return counter_name and num and xr_logic.pstor_retrieve(actor, counter_name, 0) > num
end

function counter_equal(actor, npc, p)					-- if p[1]/p[2] == nil, returns false; if counter doesn't exist, compares against 0
	local counter_name, num = p[1], p[2]
--	local c = xr_logic.pstor_retrieve(actor, counter_name, 0)
--	return counter_name and num and c == num
	return counter_name and num and xr_logic.pstor_retrieve(actor, counter_name, 0) == num
end

function counter_exists(actor, npc, p)					-- if p[1] == nil, returns false
	local counter_name = p[1]
--	local c = xr_logic.pstor_retrieve(actor, counter_name, 0)
--	return counter_name and c ~= nil
--	return counter_name and xr_logic.pstor_retrieve(actor, counter_name, 0) ~= nil		-- xr_logic.pstor_retrieve(actor, p[1], 0) never evaluates to nil because of 0 default value, which is never nil
	return counter_name and xr_logic.pstor_retrieve(actor, counter_name, nil) ~= nil	-- so in vanilla, this function always returns (a 'fake') true
end												-- set default value of counter to nil so that func. returns false if counter doesn't exist

--'------------------------------------------------------
--' Kamp
--'------------------------------------------------------

function _kamp_talk(actor, npc)
--	local npc_id = npc:id()
--	if xr_kamp.kamp_stalkers[npc_id] then
--		return xr_kamp.kamp_stalkers[npc_id]
--	end
--	return false
	return xr_kamp.kamp_stalkers[npc:id()] == true
end

--[[

function _used(actor, npc)
	return npc:is_talking()
end

]]

--'------------------------------------------------------
--' 
--'------------------------------------------------------

function has_enemy_in_current_loopholes_fov(actor, npc)
	local enemy = npc:best_enemy()
	return npc:in_smart_cover() and enemy ~= nil and npc:in_current_loophole_fov(enemy:position())
end

function smart_cover_suitable(actor, npc, p)				-- if p[1] == nil, returns false
	local smrt_cover = bind_smart_cover.registered_smartcovers[p[1]]
	return smrt_cover ~= nil and npc:suitable_smart_cover(smrt_cover)
end

function talking(actor, npc)
	return actor:is_talking()
end

function npc_talking(actor, npc)
	return npc:is_talking()
end

function actor_enemy(actor, npc)
--	local t = db.storage[npc:id()].death
	return npc:relation(actor) == game_object.enemy -- or (t ~= nil and t.killer == actor:id())
end

function is_faction_enemy_to_actor(actor, npc, p)			-- if p[1] == nil, now crashes the game instead of returning false
	local faction = p[1]
	local act = db.actor
--	return faction ~= nil and relation_registry.community_goodwill(faction, act:id()) <= -1000
	return (relation_registry.community_goodwill(faction, act:id()) + relation_registry.community_relation(faction, act:character_community())) <= -1000
end

function is_faction_friend_to_actor(actor, npc, p)			-- if p[1] == nil, now crashes the game instead of returning false
	local faction = p[1]
	local act = db.actor
--	return faction ~= nil and relation_registry.community_goodwill(faction, act:id()) >= 1000
	return (relation_registry.community_goodwill(faction, act:id()) + relation_registry.community_relation(faction, act:character_community())) >= 1000
end

function is_squad_enemy_to_actor(actor, npc, p)				-- if p[1] == nil, now crashes the game instead of returning false
	return game_relations.check_all_squad_members(p[1], "enemy")
end

function trade_exchanged(actor, npc)
	return db.storage[npc:id()].trade.exchanged
end

function trading(actor, npc)
	return db.storage[npc:id()].trade.trading
end

function hit_by_actor(actor, npc)
	local t = db.storage[npc:id()].hit
	return t ~= nil and t.who == actor:id()
end

function actor_has_weapon(actor, npc)
	local obj = actor:active_item()
	return obj ~= nil and isWeapon(obj) == true
end

function heavy_wounded(actor, npc)
	return xr_wounded.is_heavy_wounded_by_id(npc:id())
end

function time_period(actor, npc, p)					-- if p[1]/p[2] == nil, now crashes the game instead of returning false
	local tshift, period = p[1], p[2]
--	return db.actor ~= nil and tshift ~= nil and period ~= nil and tshift > period and level.get_time_minutes() % tshift <= period
	return db.actor ~= nil and tshift > period and level.get_time_minutes() % tshift <= period
end

function is_day(actor, npc)
	local tid = level.get_time_hours()
	return db.actor ~= nil and tid >= 6 and tid < 21
end

function is_dark_night(actor, npc)
	local tid = level.get_time_hours()
	return db.actor ~= nil and (tid < 3 or tid > 22)
end

--[[

function has_enemy(actor, npc)
	return npc:best_enemy() ~= nil
end

function see_enemy(actor, npc)
	local enemy = npc:best_enemy()
	return enemy ~= nil and npc:see(enemy)
end

function heli_see_actor(actor, obj)
	return obj:get_helicopter():isVisible(actor)
end

function actor_friend(actor, npc)
	return npc:relation(actor) == game_object.friend
end

function actor_neutral(actor, npc)
	return npc:relation(actor) == game_object.neutral
end

function is_factions_enemies(actor, npc, p)
	local faction = p[1]
	return faction and game_relations.is_factions_enemies(actor:character_community(), faction)
end

function is_factions_friends(actor, npc, p)
	local faction = p[1]
	return faction and game_relations.is_factions_friends(actor:character_community(), faction)
end

function is_factions_neutrals(actor, npc, p)
	return not (is_factions_enemies(actor, npc, p) or is_factions_friends(actor, npc, p))
end

function is_faction_neutral_to_actor(actor, npc, p)
	return not (is_faction_enemy_to_actor(actor, npc, p) or is_faction_friend_to_actor(actor, npc, p))
end

function is_squad_friend_to_actor(actor, npc, p)
	local squad_name = p[1]
	return squad_name and game_relations.check_all_squad_members(squad_name, "friend")
end

function is_squad_neutral_to_actor(actor, npc, p)
	return not (is_squad_enemy_to_actor(actor, npc, p) or is_squad_friend_to_actor(actor, npc, p))
end

function fighting_actor(actor, npc)
	local enemy_id = db.storage[npc:id()].enemy_id
	local enemy = db.storage[enemy_id] and db.storage[enemy_id].object
	return enemy and enemy:id() == actor:id()
end

function killed_by_actor(actor, npc)
	local t = db.storage[npc:id()].death
	return t ~= nil and t.killer == actor:id()
end

function is_arsenal_guard_rest_time(actor, npc)
	local tid = level.get_time_hours()
	return db.actor ~= nil and tid > 3 and tid < 22
end

function bar_no_sniper_time(actor, npc)
	return db.actor ~= nil and level.get_time_hours() >= 5
end

function mob_has_enemy(actor, npc)
	return npc ~= nil and npc:get_enemy() ~= nil
end

function mob_actor_nearest(actor, npc)
	return false
end

function mob_was_hit(actor, npc)
	local h = npc:get_monster_hit_info()
	return h.who and h.time ~= 0
end

]]

--'------------------------------------------------------
--' Unused SoC functions
--'------------------------------------------------------

--[[

local trade_by_level = {
	l01_escape = "escape",
	l02_garbage = "garbage",
	l03_agroprom = "garbage",
	l03u_agr_underground = "garbage",
	l04_darkvalley = "garbage",
	k01_darkscap = "garbage",
	l04u_labx18 = "garbage",
	l05_bar = "bar",
	l06_Rostok = "bar",
	l07_military = "bar",
	l08_yantar = "yantar",
	l08u_brainlab = "yantar",
	l09_deadcity = "yantar",
	l10_radar = "radar",
	l10u_bunker = "radar",
	l11_pripyat = "radar"
	}

function npc_trade_by_level(actor, npc, p)
	local trade = trade_by_level[level.name()]
	return trade ~= nil and trade == p[1]
end

function treasure_exist(actor, npc, p)
	return true
end

function can_send_tutorial(actor, npc, p)
	local act = db.actor
	return not act:is_talking() and not game.has_active_tutorial() and not act:has_info("ui_inventory") and not act:has_info("ui_pda")
end

function talking_or_tutor(actor, npc)
	return actor:is_talking() or has_alife_info("esc_trader_experienced") or has_alife_info("esc_trader_newbie")
end

]]

--'------------------------------------------------------
--' Actor state functions
--'------------------------------------------------------

function actor_in_dolg(actor, npc)
	local act = db.actor
	return act and act:character_community() == "actor_dolg"
end

function actor_in_freedom(actor, npc)
	local act = db.actor
	return act and act:character_community() == "actor_freedom"
end

function actor_in_stalker(actor, npc)
	local act = db.actor
	return act and act:character_community() == "actor_stalker"
end

function actor_in_bandit(actor, npc)
	local act = db.actor
	return act and act:character_community() == "actor_bandit"
end

function actor_on_level(actor, npc, p)					-- if p[1] == nil, returns false; if p == nil, crashes the game
	local level_name = level.name()
	for k, v in pairs (p) do
		if v == level_name then
			return true
		end
	end
	return false
end

function is_upgrading(actor, npc, p)
	return pda.upgrade_closed == false
end

function is_trading(actor, npc, p)
	return pda.trade_closed == false
end

--'------------------------------------------------------
--' Minigun support
--'------------------------------------------------------

function is_minigun_see_actor(actor, npc)
	local mgun = npc:get_car()
	return mgun:IsObjectVisible(actor)
end

--'------------------------------------------------------
--' Cover support
--'------------------------------------------------------

function cover_attack(actor, npc)
	local squad = db.storage[npc:id()].squad_obj
	return squad ~= nil and squad:cover_attack()
end

--'------------------------------------------------------
--' Squad support
--'------------------------------------------------------

function squad_in_zone(actor, npc, p)					-- returns true if even a single squad member is in zone, false if no squad member is in zone

	local squad_name, zone_name = p[1], p[2]
	if squad_name == nil or zone_name == nil then
		abort("[xr_conditions.squad_in_zone]: Parameter(s) missing.")
	end

	local squad = sim_board.get_sim_board().squads[squad_name]
	if squad == nil then
		return false
	end

	local zone = db.zone_by_name[zone_name]
	if zone == nil then
		return false
	end

	local sim = alife()
	for k in pairs (squad.squad_npc) do
		if zone:inside(sim:object(k).position) then
			return true
		end
	end

	return false
end

function attacking_smart_captured(actor, obj)

	local squad = db.storage[obj:id()].squad_obj
	if squad == nil then
		return false
	end

	if squad.always_walk ~= nil then
		return squad.always_walk
	end

	local current_action = squad.current_action
	if current_action == nil or current_action.name ~= "attack_point" then
		return false
	end

	local board = sim_board.get_sim_board()
	local self_faction_name, smrt_faction_name = board.players[squad.player_id].player_name, board.smarts[current_action.dest_smrt_id].smrt.player_name
	return smrt_faction_name ~= self_faction_name and smrt_faction_name ~= "none"
end

function npc_to_smart_dist(actor, obj, p)				-- if p[1]/p[2] == nil, crash the game

	local smart_name, distance = p[1], p[2]
	if smart_name == nil or distance == nil then
		abort("[xr_conditions.npc_to_smart_dist]: Parameter(s) missing.")
	end

	local smart, dist, gg = sim_board.get_sim_board():get_smart_by_name(smart_name), tonumber(distance), game_graph()
	return gg:vertex(obj:game_vertex_id()):level_id() == gg:vertex(smart.m_game_vertex_id):level_id() and obj:position():distance_to_sqr(smart.position) <= dist * dist
end

function current_squad_stage(actor, obj, p)				-- if p[1] == nil, crash the game

	if p[1] == nil then
		abort("[xr_conditions.current_squad_stage]: Parameter missing.")
	end

	local squad = db.storage[obj:id()].squad_obj
	if squad == nil then
		return false
	end

	local current_action = squad.current_action
	if current_action == nil or current_action.name ~= "attack_point" then
		return false
	end

--	local smrt = sim_board.get_sim_board().smarts[current_action.dest_smrt_id].smrt
	local stage = sim_board.get_sim_board().smarts[current_action.dest_smrt_id].smrt.combat_manager:get_squad_stage(squad)
--	local i = 1
--	while p[i] ~= nil do
	for i = 1, #p do
--		if smrt.combat_manager:get_squad_stage(squad) == stage then
		if stage == p[i] then
			return true
		end
--		i = i + 1
	end

	return false
end

function target_smart_name(actor, smart, p)				-- if p[1] == nil, crash the game
	local smart_name = p[1]
	if smart_name == nil then
		abort("[xr_conditions.target_smart_name]: Parameter missing.")
	end
	return smart:name() == smart_name
end

function target_resource_smart(actor, smart)
	local stype = smart.sim_type
	return stype == "resource" or stype == "territory"
end

function target_path_smart(actor, smart)
--	local faction = nil
--	local board = sim_board.get_sim_board()
	for k, v in pairs (sim_board.get_sim_board().players) do
		if v.community_player == true then
			if v.brain.interfirience_points ~= nil then
				if v.brain.interfirience_points[smart.id] ~= nil then
					return true
				end
			end
		end
	end
	return false
end

function smart_captured_by_faction(actor, obj, p)			-- if p[1]/p[2] == nil and/or p[1] doesn't denote a smart, crash the game

	local smart_name, faction_name = p[1], p[2]
	if smart_name == nil or faction_name == nil then
		abort("[xr_conditions.smart_captured_by_faction]: Parameter(s) missing.")
	end

	local smrt = sim_board.get_sim_board().smarts_by_names[smart_name]
	if smrt == nil then
		abort("[xr_conditions.smart_captured_by_faction]: Smart %s does not exist.", tostring(smart_name))
	end

	return smrt.player_name == faction_name
end

function spawn_smart_captured_by_faction(actor, smart, p)		-- if p[1] == nil, crash the game
	local faction_name = p[1]
	if faction_name == nil then
		abort("[xr_conditions.spawn_smart_captured_by_faction]: Parameter missing.")
	end
	return smart.player_name == faction_name
end

function smart_squad_population(actor, smart, p)			-- checks if the p[1] faction's squad population in smart p[2] is *less than* p[3]
	local board = sim_board.get_sim_board()				-- if p[1]/p[2]/p[3] == nil, crashes the game
	local point = board.smarts_by_names[p[2]]
	local squad_quan = board:get_smart_squad_quantity(point, board.players[p[1]]) + board:get_smart_population(point)
	return squad_quan < tonumber(p[3])
end

function is_smart_captured(actor, obj, p)				-- if p[1] == nil and/or p[1] doesn't denote a smart, crash the game

	local smart_name = p[1]
	if smart_name == nil then
		abort("[xr_conditions.is_smart_captured]: Parameter missing.")
	end

	local smrt = sim_board.get_sim_board().smarts_by_names[smart_name]
	if smrt == nil then
		abort("[xr_conditions.is_smart_captured]: Smart %s does not exist.", tostring(smart_name))
	end

	return smrt.player_name ~= "none"
end

function squad_exist(actor, npc, p)					-- if p[1] == nil, crash the game
	local squad_name = p[1]
	if squad_name == nil then
		abort("[xr_conditions.squad_exist]: Parameter missing.")
	end
	return sim_board:get_sim_board().squads[squad_name] ~= nil
end

function is_smart_defending(actor, npc, p)				-- if p[1] == nil and/or p[1] doesn't denote a smart, crash the game

	local smart_name = p[1]
	if smart_name == nil then
		abort("[xr_conditions.is_smart_defending]: Parameter missing.")
	end

	local smart = sim_board.get_sim_board():get_smart_by_name(smart_name)
	if smart == nil then
		abort("[xr_conditions.is_smart_defending]: Smart %s does not exist.", tostring(smart_name))
	end

	return smart.combat_manager:point_under_attack()
end

function is_gulag_attacking_target(actor, npc, p)
	return xr_gulag.obj_attacking_smart(npc, nil) == p[1]
end

function check_dist_to_obj_on_job_le(actor, npc, p)			-- if p[1]/p[2]/alife():object(p[1])/gulag:idNPCOnJob(p[2]) == nil, returns false; if p[3] == nil, crash the game

	local gulag = alife():object(p[1])
	if gulag == nil then
		return false
	end

	local npc_id = gulag:idNPCOnJob(p[2])
	if npc_id == nil then
		return false
	end

	local dist = p[3]
	if dist == nil then
		abort("[xr_conditions.check_dist_to_obj_on_job_le]: Parameter 3 missing.")
	end

	local obj = db.storage[npc_id] and db.storage[npc_id].object
	return obj and npc:position():distance_to(obj:position()) <= dist
end

function check_npc_squad(actor, npc, p)					-- if p[1] == nil, crash the game; if p[1] doesn't denote a squad, returns false

	local squad_name = p[1]
	if squad_name == nil then
		abort("[xr_conditions.check_npc_squad]: Parameter missing.")
	end

	local squad = sim_board:get_sim_board().squads[squad_name]
	if squad == nil then
		return false
	end

	local npc_id = alife():object(npc:name()).id
	for k in pairs (squad.squad_npc) do
		if npc_id == k then
			return true
		end
	end

	return false
end

--[[

function target_squad_name(actor, squad, p)
	local squad_name = p[1]
	if squad_name == nil then
		abort("[xr_conditions.target_squad_name]: Parameter missing.")
	end
	return squad.squad_id == squad_name
end

]]

--'------------------------------------------------------
--' Functions for Yantar
--'------------------------------------------------------

function squad_in_zone_all(actor, npc, p)				-- returns false if any squad npc is not in zone, true if all are in zone, but also (in vanilla) true if squad == nil (oddly enough)

	local squad_name, zone_name = p[1], p[2]
	if squad_name == nil or zone_name == nil then
		abort("[xr_conditions.squad_in_zone_all]: Parameter(s) missing.")
	end

	local squad = sim_board.get_sim_board().squads[squad_name]
	if squad == nil then
--		return true						-- why true?
		return false
	end

	local zone = db.zone_by_name[zone_name]
	if zone == nil then
		return false
	end

	local sim = alife()
	for k in pairs (squad.squad_npc) do
		if not zone:inside(sim:object(k).position) then
			return false
		end
	end

	return true
end

--'------------------------------------------------------
--' Functions for Stancia
--'------------------------------------------------------

function stc_check_actor_position(actor, npc, p)
	local act_pos, tostr, zone = db.actor:position(), tostring
	for i = tonumber(p[1]), 5 do
		zone = db.zone_by_name["stc_strelok_cover_"..tostr(i).."_finish"]
		if zone:inside(act_pos) then
			return true
		end
	end
	return false
end

function stc_npc_in_zone(actor, npc, p)
	local npc1, zone = level_object_by_sid(p[1]), db.zone_by_name[p[2]]
	return npc1 ~= nil and zone:inside(npc1:position())
end

function is_surge_complete()
	return xr_surge_hide.surge_finished == true
end

function is_surge_activated()
	return xr_surge_hide.surge_activated == true
end

--[[

function stc_strelok_exist(actor, npc)
	return level_object_by_sid(1400) ~= nil
end

]]

--'------------------------------------------------------
--' functions for faction expansion levels
--'------------------------------------------------------

function is_csky_at_expansion_0()
	return sim_faction.get_current_expansion("csky") == "expansion_0"
end

function is_csky_at_expansion_1()
	return sim_faction.get_current_expansion("csky") == "expansion_1"
end

function is_csky_at_expansion_2()
	return sim_faction.get_current_expansion("csky") == "expansion_2"
end

function is_csky_at_expansion_3_or_higher()
	local exp = sim_faction.get_current_expansion("csky")
	return exp ~= "expansion_0" and exp ~= "expansion_1" and exp ~= "expansion_2"
end

--[[

function is_stalker_at_expansion_0()
	return sim_faction.get_current_expansion("stalker") == "expansion_0"
end

]]

function is_stalker_at_expansion_1()
	return sim_faction.get_current_expansion("stalker") == "expansion_1"
end

function is_stalker_at_expansion_2()
	return sim_faction.get_current_expansion("stalker") == "expansion_2"
end

function is_stalker_at_expansion_3_or_higher()
	local exp = sim_faction.get_current_expansion("stalker")
	return exp ~= "expansion_0" and exp ~= "expansion_1" and exp ~= "expansion_2"
end

function is_stalker_at_expansion_4_or_higher()
	local exp = sim_faction.get_current_expansion("stalker")
	return exp ~= "expansion_0" and exp ~= "expansion_1" and exp ~= "expansion_2" and exp ~= "expansion_3"
end

--[[

function is_bandit_at_expansion_0()
	return sim_faction.get_current_expansion("bandit") == "expansion_0"
end

]]

function is_bandit_at_expansion_1()
	return sim_faction.get_current_expansion("bandit") == "expansion_1"
end

function is_bandit_at_expansion_2()
	return sim_faction.get_current_expansion("bandit") == "expansion_2"
end

function is_bandit_at_expansion_3_or_higher()
	local exp = sim_faction.get_current_expansion("bandit")
	return exp ~= "expansion_0" and exp ~= "expansion_1" and exp ~= "expansion_2"
end

--[[

function is_freedom_at_expansion_0()
	return sim_faction.get_current_expansion("freedom") == "expansion_0"
end

]]

function is_freedom_at_expansion_1()
	return sim_faction.get_current_expansion("freedom") == "expansion_1"
end

function is_freedom_at_expansion_2()
	return sim_faction.get_current_expansion("freedom") == "expansion_2"
end

function is_freedom_at_expansion_3_or_higher()
	local exp = sim_faction.get_current_expansion("freedom")
	return exp ~= "expansion_0" and exp ~= "expansion_1" and exp ~= "expansion_2"
end

--[[

function is_dolg_at_expansion_0()
	return sim_faction.get_current_expansion("dolg") == "expansion_0"
end

]]

function is_dolg_at_expansion_1()
	return sim_faction.get_current_expansion("dolg") == "expansion_1"
end

function is_dolg_at_expansion_2()
	return sim_faction.get_current_expansion("dolg") == "expansion_2"
end

function is_dolg_at_expansion_3_or_higher()
	local exp = sim_faction.get_current_expansion("dolg")
	return exp ~= "expansion_0" and exp ~= "expansion_1" and exp ~= "expansion_2"
end

function is_faction_resource_greater(actor, npc, p)			-- if p[1]/p[2] == nil, crash the game
	local faction_name, resource = p[1], p[2]
	if faction_name == nil or resource == nil then
		abort("[xr_conditions.is_faction_resource_greater]: Parameter(s) missing.")
	end
	return sim_faction.get_current_resource(faction_name) >= tonumber(resource)
end

--'------------------------------------------------------
--' Minigame functions
--'------------------------------------------------------

function is_shooting_finished(actor, npc, p)
	return minigame_dialogs.is_shooting_finished()
end

function check_crowkiller_state(actor, npc, p)
	local state, m = p[1], minigames_manager.get_minigames_manager()
	local crowkiller = m:get_current_crowkiller()
	return state ~= nil and crowkiller ~= "" and m:get_minigame_state(crowkiller) == state
end

function crowkiller_winned(actor, npc, p)
	local m = minigames_manager.get_minigames_manager()
	local crowkiller = m:get_current_crowkiller()
	return crowkiller ~= "" and m:get_minigame_state(crowkiller) == "finished" and m:get_minigame_param(crowkiller, "win")
end

function crowkiller_game_type(actor, npc, p)
	local type, m = p[1], minigames_manager.get_minigames_manager()
	local crowkiller = m:get_current_crowkiller()
	return (type == "highscore" or type == "training" or type == "money") and m:get_minigame_param(crowkiller, "game_type") == type
end

--'------------------------------------------------------
--' Relation functions
--'------------------------------------------------------

function gulag_enemy_actor(actor, npc, p)				-- returns false if p[1] == nil because of game_relations.get_gulag_relation_actor
	return game_relations.get_gulag_relation_actor(p[1], "enemy")
end

function gulag_friend_actor(actor, npc, p)
	return game_relations.get_gulag_relation_actor(p[1], "friend")	-- returns false if p[1] == nil because of game_relations.get_gulag_relation_actor
end

function gulag_neutral_actor(actor, npc, p)
	return game_relations.get_gulag_relation_actor(p[1], "neutral")	-- returns false if p[1] == nil because of game_relations.get_gulag_relation_actor
end

function quest_npc_enemy_actor(actor, npc, p)				-- if p[1] == nil, crash the game
	local npc_id = p[1]
	if npc_id == nil then
		abort("[xr_conditions.quest_npc_enemy_actor]: Parameter missing.")
	end
	local act, obj = db.actor, level_object_by_sid(npc_id)
	return act and obj and IsStalker(obj) and obj:general_goodwill(act) <= -1000
end

--'------------------------------------------------------
--' Miscellaneous
--'------------------------------------------------------

function signal_rocket_flying(actor, npc, p)				-- if p[1] == nil and/or p[1] doesn't denote a signal rocket, crash the game
	local rocket_name = p[1]
	if rocket_name == nil then
		abort("[xr_conditions.signal_rocket_flying]: Parameter missing.")
	end
	local dbsig = db.signal_light[rocket_name]
	if dbsig == nil then
		abort("[xr_conditions.signal_rocket_flying]: No signal rocket corresponds to parameter %s.", tostring(rocket_name))
	end
	return dbsig:is_flying()
end

function is_current_action_robbery(actor, npc)
	local manager = npc:motivation_action_manager()
	return manager and manager:initialized() and manager:current_action_id() == xr_actions_id.actor_reaction + 1
end

function get_task_by_smart(actor, npc, p)				-- if p[1] == nil, crashes the game
--	local smart_id = sim_board.get_sim_board().smarts_by_names[p[1]].id
--	local task = task_manager.get_task_manager():get_tasks_by_smart(smart_id)
--	return task ~= nil
	return task_manager.get_task_manager():get_tasks_by_smart(sim_board.get_sim_board().smarts_by_names[p[1]].id) ~= nil
end

function is_smart_in_combat(actor, npc, p)				-- if p[1] == nil, crash the game
	if p[1] == nil then
		abort("[xr_conditions.is_smart_in_combat]: Parameter missing.")
	end
	local pairs, board, smart, squad_stage = pairs, sim_board.get_sim_board()
	for k, v in pairs (p) do
		smart = board:get_smart_by_name(v)
		for kk, vv in pairs (board.smarts[smart.id].squads) do
			squad_stage = smart.combat_manager:get_squad_stage(vv)
			if squad_stage == "combat" or squad_stage == "defence" then
				return true
			end
		end
	end
	return false
end

function npc_stay_offline(actor, npc, p)				-- if p[1] == nil, crash the game
	local smart_name = p[1]
	if smart_name == nil then
		abort("[xr_conditions.npc_stay_offline]: Parameter missing.")
	end
--	return db.actor and npc and (is_smart_in_combat(actor, npc, p) or game_relations.get_gulag_relation_actor(p[1], "enemy"))
	return is_smart_in_combat(nil, nil, p) or get_task_by_smart(nil, nil, p) or game_relations.some_smart_members_hostile(smart_name)
end

function distance_to_obj_ge(actor, npc, p)				-- if p[1]/p[2]/obj/db.actor == nil or type(p[2]) ~= number, return
	local act, obj, dist = db.actor, level_object_by_sid(p[1]), p[2]
	if act == nil or obj == nil or dist == nil or type(dist) ~= "number" then
		return
	end
	return distance_between(obj, act) >= dist
end

function distance_to_obj_le(actor, npc, p)				-- if p[1]/p[2]/obj/db.actor == nil or type(p[2]) ~= number, return
	local act, obj, dist = db.actor, level_object_by_sid(p[1]), p[2]
	if act == nil or obj == nil or dist == nil or type(dist) ~= "number" then
		return
	end
	return distance_between(obj, act) <= dist
end

--[[

function is_squad_reached_position(actor, npc, p)
	local squad, npc_storage, not_there = sim_board.squads[squad_id]
	for kk, npc in pairs (squad.squad_npc) do
		npc_storage = db.storage[kk]
		if npc_storage ~= nil then
			not_there = xr_logic.check_action(npc_storage.object, npc_storage[npc_storage.active_scheme], "position_riched") == false
			if not_there then
				return false
			end
		end
	end
	return true
end

]]

----------------------------------------------------------------------------------------------
--	SRP functions:
----------------------------------------------------------------------------------------------

function npc_is_squad_leader(actor, npc)
	local npc_id = npc.id
	local se_npc = alife():object(npc_id)
	local squad = sim_board.get_sim_board().squads[se_npc and se_npc.squad_id]
	return squad and squad.commander_id == npc_id
end

function npc_is_in_attacking_squad(actor, npc)
	local se_npc = alife():object(npc.id)
	local squad = sim_board.get_sim_board().squads[se_npc and se_npc.squad_id]
	return squad and squad.current_action and squad.current_action.name == "attack_point"
end

function actor_dist_to_zone_le(actor, npc, p)
	local zone_name, distance = p[1], p[2]
	if zone_name == nil or distance == nil then
		abort("[xr_conditions.actor_dist_to_zone_le]: Parameter(s) missing.")
	end
	local zone = db.zone_by_name[zone_name]
	local dist = tonumber(distance)
	return actor:position():distance_to_sqr(zone:position()) <= dist * dist
end

function npc_dist_to_zone_le(actor, npc, p)
	local zone_name, distance = p[1], p[2]
	if zone_name == nil or distance == nil then
		abort("[xr_conditions.npc_dist_to_zone_le]: Parameter(s) missing.")
	end
	local zone = db.zone_by_name[zone_name]
	local dist = tonumber(distance)
	return npc:position():distance_to_sqr(zone:position()) <= dist * dist
end

function actor_is_talking()
	return pda.dialog_closed == false
end
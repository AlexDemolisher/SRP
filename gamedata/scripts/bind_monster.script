-----------------------------------------------------------------------------------
-- Monster binding
-----------------------------------------------------------------------------------

function bind(obj)
	local new_binder = generic_object_binder(obj)
	obj:bind_object(new_binder)
end

-- local last_update = 0 -- combat

------------------------------------------------------------------------------------

class "generic_object_binder" (object_binder)

function generic_object_binder:__init(obj) super(obj)
	self.loaded = false
end

function generic_object_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_object_binder:reinit()

	object_binder.reinit(self)

	local sobj = self.object

	if sobj:clsid() ~= clsid.script_trader then
		sobj:set_patrol_extrapolate_callback(generic_object_binder.extrapolate_callback, self)
	end

	local t = {}

	db.storage[sobj:id()] = t

	self.st = t

	sobj:set_callback(callback.patrol_path_in_point, self.waypoint_callback, self)
	sobj:set_callback(callback.hit, self.hit_callback, self)
	sobj:set_callback(callback.death, self.death_callback, self)
end

function generic_object_binder:update(delta)

	object_binder.update(self, delta)

	local sobj = self.object
	local sobj_id = sobj:id()

	if bind_stalker.to_delayed_alife_release_objects[sobj_id] == true then
		local sim = alife()
		sim:release(sim:object(sobj_id), true)
		bind_stalker.to_delayed_alife_release_objects[sobj_id] = nil
		return
	end

	if sobj:clsid() == clsid.script_trader then
--		dbgmsg("[bind_monster.update]: Trader update!")
		trade_manager.update(sobj)
	end

	if sobj:alive() then

		if sobj:is_talk_enabled() then
			sobj:set_tip_text("character_use")
		else
			sobj:set_tip_text("")
		end

		local st = db.storage[sobj_id]
		if st ~= nil then

			local active_scheme = st.active_scheme
			if active_scheme ~= nil then
				xr_logic.try_switch_to_another_section(sobj, st[active_scheme], db.actor)
			end

			local squad = st.squad_obj
			if squad ~= nil then
				if squad.commander_id == sobj_id then
					squad:update()
				end
			end
		end
	else
		sobj:set_tip_text_default()
	end

	local self_st = self.st
	if self_st.active_section ~= nil then
		xr_logic.issue_event(sobj, self_st[self_st.active_scheme], "update", delta)
	end
end

function generic_object_binder:extrapolate_callback()

	local sobj = self.object
	local sobj_st = db.storage[sobj:id()]

	if sobj_st == nil or sobj_st.object == nil then
		return
	end

	local cur_pt = sobj:get_current_point_index()

	if sobj:get_script() == false then
		return false
	end

	local patrol_path = sobj:patrol()
	if not level.patrol_path_exists(patrol_path) then
		return false
	end

	if patrol(patrol_path):flags(cur_pt):get() == 0 then
		return true
	end

	return false
end

function generic_object_binder:waypoint_callback(obj, action_type, index)
	if self.st.active_section ~= nil then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "waypoint_callback", obj, action_type, index)
	end
end

function generic_object_binder:death_callback(victim, who)

	local sobj = self.object
	local act = db.actor

	if who:id() == act:id() then
		xr_statistic.addKillCount(sobj)
		xr_statistic.inc_killed_monsters_counter()
	end

	local self_st = self.st
	local mob_death = self_st.mob_death

	if mob_death then
		xr_logic.issue_event(sobj, mob_death, "death_callback", victim, who)
	end

	if self_st.active_section then
		xr_logic.issue_event(sobj, self_st[self_st.active_scheme], "death_callback", victim, who)
	end

	local h = hit()
	h.draftsman = sobj
	h.type = hit.fire_wound
	h.direction = act:position():sub(sobj:position())
	h:bone("pelvis")
	h.power = 1
	h.impulse = 10
	sobj:hit(h)

	sobj:set_callback(callback.death, nil)			-- SRP
	sobj:set_callback(callback.patrol_path_in_point, nil)	-- SRP
	sobj:set_callback(callback.hit, nil)			-- SRP

	if sobj:clsid() == clsid.poltergeist_s then
		local sim = alife()
--		local sim_obj = sim:object(sobj:name())
		local sim_obj = sim:object(sobj:id())
		if sim_obj ~= nil then
			sim:release(sim_obj, true)
		end
	end
end

function generic_object_binder:hit_callback(obj, amount, local_direction, who, bone_index)

	local sobj = self.object
	local self_st_hit = self.st.hit

	if self_st_hit then
		xr_logic.issue_event(sobj, self_st_hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	local who_id = who:id()

	if amount > 0 then
		sim_combat.hit_callback(sobj:id(), who_id)
	end

	if string.find(obj:name(), "bloodsucker_jumper") ~= nil then
		if who_id ~= db.actor:id() then
			obj.health = obj.health + amount
		end
	end
end

function generic_object_binder:net_spawn(sobject)

	if not object_binder.net_spawn(self, sobject) then
		return false
	end

	local sobj = self.object

	if not sobj:alive() then
		return true
	end

	local sim = alife()
	local sobj_id = sobj:id()
	local sim_obj = sim:object(sobj_id)

	if sim_obj == nil then
		return false
	end

	db.storage[sobj_id].squad_obj = sim_board.get_sim_board().squads[sim_obj.squad_id]

	db.add_obj(sobj)

	if sobj:clsid() == clsid.script_trader then
		smart_terrain.setup_gulag_and_logic_on_spawn(sobj, self.st, sobject, modules.stype_trader, self.loaded)
	else
		smart_terrain.setup_gulag_and_logic_on_spawn(sobj, self.st, sobject, modules.stype_mobile, self.loaded)
	end

	return true
end

function generic_object_binder:net_destroy()

	local sobj = self.object

	sobj:set_callback(callback.death, nil)
	sobj:set_callback(callback.patrol_path_in_point, nil)
	sobj:set_callback(callback.hit, nil)

	local sobj_id = sobj:id()

	xr_sound.stop_sounds_by_id(sobj_id)

	local st = db.storage[sobj_id]
	if st and st.active_scheme then
		xr_logic.issue_event(sobj, st[st.active_scheme], "net_destroy")
	end

--	db.del_obj(sobj)		-- done below
	db.storage[sobj_id] = nil
	object_binder.net_destroy(self)
end
--[[
function generic_object_binder:reload(section)	-- duplicate
	object_binder.reload(self, section)
end
]]
function generic_object_binder:net_save_relevant()
	return true
end

function generic_object_binder:save(packet)
	set_save_marker(packet, "save", false, "generic_object_binder")
	object_binder.save(self, packet)
	xr_logic.save_obj(self.object, packet)
--	if self.object:clsid() == clsid.script_trader then
--		trade_manager.save(self.object, packet)
--	end
	set_save_marker(packet, "save", true, "generic_object_binder")
end

function generic_object_binder:load(reader)
	self.loaded = true
	set_save_marker(reader, "load", false, "generic_object_binder")
	object_binder.load(self, reader)
	xr_logic.load_obj(self.object, reader)
--	if self.object:clsid() == clsid.script_trader then
--		trade_manager.load(self.object, reader)
--	end
	set_save_marker(reader, "load", true, "generic_object_binder")
end
function init(obj)

	local ini = obj:spawn_ini()
	if ini and ini:section_exist("animation") then
		abort("object '%s': animation section is deprecated, use logic + impulse combination", obj:name())
		return
	end

	if not (ini and ini:section_exist("logic")) then
		if obj:clsid() ~= clsid.inventory_box then
			return
		end
	end

	db.storage[obj:id()] = {}

	local new_binder = generic_physics_binder(obj)
	obj:bind_object(new_binder)
end

---------------------------------------------------------------------------------------------

class "generic_physics_binder" (object_binder)

function generic_physics_binder:__init(obj) super(obj)
	self.initialized = false
	self.loaded = false
end

function generic_physics_binder:reload(section)
	object_binder.reload(self, section)
end

function generic_physics_binder:reinit()
	object_binder.reinit(self)
	self.st = db.storage[self.object:id()]
end

function generic_physics_binder:update(delta)

	object_binder.update(self, delta)

	local sobj = self.object
	local self_st = self.st

	if not self.initialized then
		local act = db.actor
		if act then
			self.initialized = true
			xr_logic.initialize_obj(sobj, self_st, self.loaded, act, modules.stype_item)
			local particle = utils.cfg_get_string(self_st.ini, self_st.section_logic, "particle", sobj, false, "", nil)
			if particle ~= nil then
				self.particle = particles_object(particle)
				self.particle:play_at_pos(sobj:position())
			end
		end
	end

	if self_st.active_section ~= nil or (sobj:spawn_ini() ~= nil and sobj:spawn_ini():section_exist("drop_box") == true) then
		xr_logic.issue_event(sobj, self_st[self_st.active_scheme], "update", delta)
		sobj:set_callback(callback.hit, generic_physics_binder.hit_callback, self)
		sobj:set_callback(callback.death, generic_physics_binder.death_callback, self)
		sobj:set_callback(callback.use_object, generic_physics_binder.use_callback, self)
	end

	if sobj:clsid() == clsid.inventory_box then
		sobj:set_callback(callback.use_object, generic_physics_binder.use_callback, self)
	end

	xr_sound.update(sobj:id())
end

function generic_physics_binder:net_spawn(data)

	if not object_binder.net_spawn(self, data) then
		return false
	end

	local sobj = self.object
	local ssid = sobj:clsid()

--	if ssid == clsid.projector then
--		db.add_sl(sobj)
--	end

	local spawn_ini = sobj:spawn_ini()

	if spawn_ini ~= nil then
		if spawn_ini:section_exist("drop_box") == true then
			self.box_items = xr_box.ph_item_box(sobj)
		end
	end

	db.add_obj(sobj)

	if ssid == clsid.inventory_box then
		local sname = sobj:name()
		if sname ~= "gar_treasure_quest_reward_in_anomaly" then
			if sname ~= "gar_treasure_quest_old_pda" then

				local actor_level = level.name()

				if (actor_level == "marsh" and has_alife_info("mar_stashes_filled"))
				or (actor_level == "escape" and has_alife_info("esc_stashes_filled"))
				or (actor_level == "garbage" and has_alife_info("gar_stashes_filled"))
				or (actor_level == "darkvalley" and has_alife_info("val_stashes_filled"))
				or (actor_level == "agroprom" and has_alife_info("agr_stashes_filled"))
				or (actor_level == "agroprom_underground" and has_alife_info("agru_stashes_filled"))
				or (actor_level == "yantar" and has_alife_info("yan_stashes_filled"))
				or (actor_level == "red_forest" and has_alife_info("red_stashes_filled"))
				or (actor_level == "military" and has_alife_info("mil_stashes_filled"))
				or (actor_level == "limansk" and has_alife_info("lim_stashes_filled"))
				or (actor_level == "hospital" and has_alife_info("kat_stashes_filled")) then
					return true
				end

				treasure_manager.use_box(sobj)

--				dbglog("Used box with name "..sname.." and ID "..sobj:id()..".")
			end
		end
	end

	return true
end

function generic_physics_binder:net_destroy()

	local sobj = self.object
	local sid = sobj:id()

	xr_sound.stop_sounds_by_id(sid)

	sobj:set_callback(callback.hit, nil)		-- SRP
	sobj:set_callback(callback.death, nil)		-- SRP
	sobj:set_callback(callback.use_object, nil)	-- SRP

	local st = db.storage[sid]
	if st.active_scheme then
		xr_logic.issue_event(sobj, st[st.active_scheme], "net_destroy")
	end

	if self.particle ~= nil then
		self.particle:stop()
	end

--	db.del_obj(sobj)	-- done below
--	db.del_sl(sobj)

	db.storage[sid] = nil

	object_binder.net_destroy(self)
end

function generic_physics_binder:net_save_relevant()
	return true
end

function generic_physics_binder:save(packet)
	object_binder.save(self, packet)
	set_save_marker(packet, "save", false, "physics_binder")
	xr_logic.save_obj(self.object, packet)
	set_save_marker(packet, "save", true, "physics_binder")
end

function generic_physics_binder:load(reader)
	self.loaded = true
	object_binder.load(self, reader)
	set_save_marker(reader, "load", false, "physics_binder")
	xr_logic.load_obj(self.object, reader)
	set_save_marker(reader, "load", true, "physics_binder")
end

function generic_physics_binder:use_callback(obj, who)
	if obj:clsid() == clsid.inventory_box then
		if obj:name() == "gar_smart_terrain_5_6_box" then
			local act = db.actor
			if act:has_info("gar_quest_redemption_started") then
				act:give_info_portion("gar_quest_redemption_done")
			end
		end
--		treasure_manager.use_box(obj, who)
	end
	local self_st = self.st
	if self_st.active_section then
		xr_logic.issue_event(self.object, self_st[self_st.active_scheme], "use_callback", obj, who)
	end
end

function generic_physics_binder:hit_callback(obj, amount, local_direction, who, bone_index)

	local sobj = self.object
	local self_st = self.st

	if self_st.ph_on_hit then
		xr_logic.issue_event(sobj, self_st.ph_on_hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end

	if self_st.active_section then
		xr_logic.issue_event(sobj, self_st[self_st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
	end
end

function generic_physics_binder:death_callback(victim, who)

	local sobj = self.object
	local self_st = self.st

	if self_st.active_section then
		xr_logic.issue_event(sobj, self_st[self_st.active_scheme], "death_callback", victim, who)
	end

	sobj:set_callback(callback.hit, nil)		-- SRP
	sobj:set_callback(callback.death, nil)		-- SRP
	sobj:set_callback(callback.use_object, nil)	-- SRP

	if self.particle ~= nil then
		self.particle:stop()
	end

	if self.disable_graph_point ~= nil then
		game_graph():accessible(self.disable_graph_point, true)
	end

	local spawn_ini = sobj:spawn_ini()

	if spawn_ini ~= nil then
		if spawn_ini:section_exist("drop_box") == true then
			self.box_items:spawn_items()
		end
	end
end